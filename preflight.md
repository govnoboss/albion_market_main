# Preflight Analysis: Smart Buyer Mode (Checkbox Implementation)

## 1. Фаза Цели
**Цель**: Дать пользователю выбор между "Стандартным" закупщиком (по списку) и "Умным" закупщиком (по выгодности), используя простой чекбокс.
**Проблема**: Сейчас работает только стандартный режим. Пользователь хочет автоматизацию поиска выгоды, но с защитой от устаревших данных.
**Метрика**:
1.  Пользователь может включить "Умный закупщик".
2.  Если цены старые (>10 часов), появляется предупреждение.
3.  Бот покупает самые выгодные товары, если режим включен.

## 2. Фаза Классификации
**Тип**: Новая фича (возврат ранее удаленной, но в другом UX) + Защита (data freshness check).

## 3. Фаза Влияния
*   **UI**: Добавить `QCheckBox` "Smart Buyer" в `buyer_window.py`.
*   **Core**:
    *   В `buyer.py` восстановить логику сортировки по профиту (`_run_smart_mode`).
    *   Добавить проверку времени обновления цен (`updated` timestamp).

## 4. Фаза Инвариантов
*   **Safety**: Бот не должен покупать "вслепую", если данных нет.
*   **Freshness**: Если данные старые, пользователь должен явно разрешить риск.

## 5. Фаза Edge Cases
1.  **No Data**: Чекбокс включен, но `prices.json` пустой. -> Ошибка "Сначала сканируйте".
2.  **Stale Data**: Данные есть, но им 20 часов. -> Warning Popup.
3.  **Missing BM Prices**: Есть цены рынка, но нет цен ЧР. -> Пропуск предмета (так как профит не посчитать).
4.  **Mixed Freshness**: Часть цен свежие, часть старые. -> Считаем по "худшему" или предупреждаем, если *хотя бы одна* старая? В ТЗ: "Если цены... сканировались более чем 10 часов назад". Проверим среднее или min timestamp. Лучше проверить: *Если большинство цен старые*? Нет, сделаем строго: если найдена хоть одна старая запись для текущего города -> Warning.

## 6. Фаза Архитектуры
*   `BuyerWindow`: управляет флагом `smart_mode`.
*   `BuyerBot`:
    *   `run()` проверяет флаг.
    *   `_check_freshness()`: вспомогательный метод.
    *   `_run_smart()`: логика цикла.

## 7. Фаза MVP
*   Checkbox в UI.
*   Warning Logic перед стартом бота (в потоке бота или в UI?).
    *   *Важно*: `BuyerBot` работает в треде. `QMessageBox` нельзя вызывать из треда напрямую.
    *   *Решение*: Проверку на свежесть делать в UI **перед** запуском `bot.start()`. Это проще и безопаснее для GUI.

## 8. Вердикт
✅ **Готово к реализации**.
План:
1.  UI: Добавить чекбокс.
2.  UI: В `_on_start_clicked`:
    *   Если Smart=True:
        *   Проверить наличие данных в `PriceStorage`.
        *   Проверить даты обновлений.
        *   Если старые -> `QMessageBox.question`. Если No -> return.
    *   Запустить `bot.start(smart=True)`.
3.  Core: Реализовать `_run_smart` в `BuyerBot`.
